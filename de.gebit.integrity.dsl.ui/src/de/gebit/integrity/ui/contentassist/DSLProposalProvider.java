/*
 * generated by Xtext
 */
package de.gebit.integrity.ui.contentassist;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.search.IJavaSearchConstants;
import org.eclipse.jdt.core.search.IJavaSearchScope;
import org.eclipse.jdt.core.search.SearchEngine;
import org.eclipse.jdt.core.search.SearchMatch;
import org.eclipse.jdt.core.search.SearchParticipant;
import org.eclipse.jdt.core.search.SearchPattern;
import org.eclipse.jdt.core.search.SearchRequestor;
import org.eclipse.jdt.internal.core.CompilationUnit;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.common.types.util.jdt.IJavaElementFinder;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;

import com.google.inject.Inject;

import de.gebit.integrity.dsl.ArbitraryParameterName;
import de.gebit.integrity.dsl.Call;
import de.gebit.integrity.dsl.CallDefinition;
import de.gebit.integrity.dsl.MethodReference;
import de.gebit.integrity.dsl.Parameter;
import de.gebit.integrity.dsl.ParameterTableHeader;
import de.gebit.integrity.dsl.TableTest;
import de.gebit.integrity.dsl.Test;
import de.gebit.integrity.dsl.TestDefinition;
import de.gebit.integrity.fixtures.ArbitraryParameterFixture;
import de.gebit.integrity.fixtures.ArbitraryParameterFixture.ArbitraryParameterDefinition;
import de.gebit.integrity.fixtures.ArbitraryParameterFixture.EclipseResourceProvider;
import de.gebit.integrity.fixtures.Fixture;
import de.gebit.integrity.ui.utils.ClassLoadingUtil;
import de.gebit.integrity.utils.IntegrityDSLUtil;
import de.gebit.integrity.utils.JavadocUtil;
import de.gebit.integrity.utils.ParamAnnotationTuple;

/**
 * see
 * http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on
 * how to customize content assistant
 */
@SuppressWarnings("restriction")
public class DSLProposalProvider extends AbstractDSLProposalProvider {

	@Inject
	IJavaElementFinder elementFinder;

	@Override
	public void completeTest_Parameters(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completeTest_Parameters(model, assignment, context, acceptor);

		Test tempTest = (Test) model;
		TestDefinition tempTestDef = tempTest.getDefinition();
		if (tempTestDef != null) {
			Set<String> tempAlreadyUsedParameters = new HashSet<String>();
			for (Parameter tempParameter : tempTest.getParameters()) {
				tempAlreadyUsedParameters.add(IntegrityDSLUtil.getParamNameStringFromParameterName(tempParameter
						.getName()));
			}
			completeParametersInternal(tempAlreadyUsedParameters, tempTestDef.getFixtureMethod(), null, context,
					acceptor);
		}
	}

	@Override
	public void completeCall_Parameters(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completeCall_Parameters(model, assignment, context, acceptor);

		Call tempCall = (Call) model;
		CallDefinition tempCallDef = tempCall.getDefinition();
		if (tempCallDef != null) {
			Set<String> tempAlreadyUsedParameters = new HashSet<String>();
			for (Parameter tempParameter : tempCall.getParameters()) {
				tempAlreadyUsedParameters.add(IntegrityDSLUtil.getParamNameStringFromParameterName(tempParameter
						.getName()));
			}
			completeParametersInternal(tempAlreadyUsedParameters, tempCallDef.getFixtureMethod(), null, context,
					acceptor);
		}
	}

	@Override
	public void completeTableTest_Parameters(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completeTableTest_Parameters(model, assignment, context, acceptor);

		TableTest tempTableTest = (TableTest) model;
		TestDefinition tempTestDef = tempTableTest.getDefinition();
		if (tempTestDef != null) {
			Set<String> tempAlreadyUsedParameters = new HashSet<String>();
			for (Parameter tempParameter : tempTableTest.getParameters()) {
				tempAlreadyUsedParameters.add(IntegrityDSLUtil.getParamNameStringFromParameterName(tempParameter
						.getName()));
			}
			for (ParameterTableHeader tempHeader : tempTableTest.getHeaders()) {
				tempAlreadyUsedParameters
						.add(IntegrityDSLUtil.getParamNameStringFromParameterName(tempHeader.getName()));
			}

			completeParametersInternal(tempAlreadyUsedParameters, tempTestDef.getFixtureMethod(), null, context,
					acceptor);
		}
	}

	@Override
	public void completeTableTest_Headers(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completeTableTest_Headers(model, assignment, context, acceptor);

		TableTest tempTableTest = (TableTest) model;
		TestDefinition tempTestDef = tempTableTest.getDefinition();
		if (tempTestDef != null) {
			Set<String> tempAlreadyUsedParameters = new HashSet<String>();
			for (Parameter tempParameter : tempTableTest.getParameters()) {
				tempAlreadyUsedParameters.add(IntegrityDSLUtil.getParamNameStringFromParameterName(tempParameter
						.getName()));
			}
			for (ParameterTableHeader tempParameterHeader : tempTableTest.getHeaders()) {
				tempAlreadyUsedParameters.add(IntegrityDSLUtil.getParamNameStringFromParameterName(tempParameterHeader
						.getName()));
			}
			completeParametersInternal(tempAlreadyUsedParameters, tempTestDef.getFixtureMethod(), "| ", context,
					acceptor);
		}
	}

	@Override
	public void completeParameterTableHeader_Name(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completeParameterTableHeader_Name(model, assignment, context, acceptor);

		TableTest tempTableTest = (TableTest) model;
		TestDefinition tempTestDef = (tempTableTest).getDefinition();
		if (tempTestDef != null) {
			Set<String> tempAlreadyUsedParameters = new HashSet<String>();
			for (ParameterTableHeader tempParameterHeader : tempTableTest.getHeaders()) {
				tempAlreadyUsedParameters.add(IntegrityDSLUtil.getParamNameStringFromParameterName(tempParameterHeader
						.getName()));
			}
			completeParametersInternal(tempAlreadyUsedParameters, tempTestDef.getFixtureMethod(), null, context,
					acceptor);
		}
	}

	private void completeParametersInternal(Set<String> someAlreadyUsedParameters, MethodReference aMethod,
			String aPrefix, ContentAssistContext aContext, ICompletionProposalAcceptor anAcceptor) {

		Map<String, String> tempJavadocMap = JavadocUtil.getMethodParamJavadoc(aMethod.getMethod(), elementFinder);

		List<ParamAnnotationTuple> tempParamList = IntegrityDSLUtil.getAllParamNamesFromFixtureMethod(aMethod);
		for (ParamAnnotationTuple tempParam : tempParamList) {
			if (!someAlreadyUsedParameters.contains(tempParam.getParamName())) {
				String tempJavadocDescription = tempJavadocMap != null ? tempJavadocMap.get(tempParam
						.getJavaParamName()) : null;
				String tempDisplayText = null;
				if (tempJavadocDescription != null) {
					tempDisplayText = tempParam.getParamName() + ": " + tempJavadocDescription;
				} else {
					tempDisplayText = tempParam.getParamName();
				}
				anAcceptor.accept(createCompletionProposal((aPrefix != null ? aPrefix : "") + tempParam.getParamName(),
						tempDisplayText, null, aContext));
			}
		}
	}

	@Override
	public void completeArbitraryParameterName_Identifier(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.completeArbitraryParameterName_Identifier(model, assignment, context, acceptor);

		EObject tempContainer = null;
		if (model instanceof Parameter) {
			tempContainer = model.eContainer();
		} else if (model instanceof ArbitraryParameterName) {
			tempContainer = model.eContainer().eContainer();
		}
		Map<String, Object> tempParameterMap = null;

		MethodReference tempMethodReference = null;
		if (tempContainer instanceof Test) {
			Test tempTest = (Test) tempContainer;
			tempParameterMap = IntegrityDSLUtil.createParameterMap(tempTest.getParameters(), null, true);
			tempMethodReference = tempTest.getDefinition().getFixtureMethod();
		} else if (tempContainer instanceof TableTest) {
			TableTest tempTest = (TableTest) tempContainer;
			tempParameterMap = IntegrityDSLUtil.createParameterMap(tempTest.getParameters(), null, true);
			tempMethodReference = tempTest.getDefinition().getFixtureMethod();
		} else if (tempContainer instanceof Call) {
			Call tempCall = (Call) tempContainer;
			tempParameterMap = IntegrityDSLUtil.createParameterMap(tempCall.getParameters(), null, true);
			tempMethodReference = tempCall.getDefinition().getFixtureMethod();
		}

		if (tempParameterMap != null && tempMethodReference != null && tempMethodReference.getType() != null) {
			IJavaElement tempSourceMethod = (IJavaElement) elementFinder.findElementFor(tempMethodReference.getType());

			CompilationUnit tempCompilationUnit = (CompilationUnit) tempSourceMethod.getParent();
			Class<?> tempFixtureClass;
			try {
				tempFixtureClass = ClassLoadingUtil.loadClassFromWorkspace(
						tempCompilationUnit.getTypes()[0].getFullyQualifiedName(), tempSourceMethod.getJavaProject());
				Fixture tempFixtureInstance = (Fixture) tempFixtureClass.newInstance();

				if (tempFixtureInstance instanceof ArbitraryParameterFixture) {
					Map<String, Object> tempFixedParameterMap = null;
					if (tempContainer instanceof Test) {
						Test tempTest = (Test) tempContainer;
						tempFixedParameterMap = IntegrityDSLUtil.createParameterMap(tempTest.getParameters(), null,
								false);
					} else if (tempContainer instanceof TableTest) {
						TableTest tempTest = (TableTest) tempContainer;
						tempFixedParameterMap = IntegrityDSLUtil.createParameterMap(tempTest.getParameters(), null,
								false);
					} else if (tempContainer instanceof Call) {
						Call tempCall = (Call) tempContainer;
						tempFixedParameterMap = IntegrityDSLUtil.createParameterMap(tempCall.getParameters(), null,
								false);
					}

					tempFixtureInstance.convertParameterValuesToFixtureDefinedTypes(Fixture.findFixtureMethodByName(
							tempFixtureClass, tempMethodReference.getMethod().getSimpleName()), tempFixedParameterMap,
							false, generateResourceProvider());

					List<ArbitraryParameterDefinition> tempParameterDescriptions = ((ArbitraryParameterFixture) tempFixtureInstance)
							.defineArbitraryParameters(tempMethodReference.getMethod().getSimpleName(),
									tempFixedParameterMap, generateResourceProvider());
					for (ArbitraryParameterDefinition tempParameterDescription : tempParameterDescriptions) {
						String tempName = tempParameterDescription.getName();
						if (!tempParameterMap.containsKey(tempName)) {
							String tempDescription = tempName;
							if (tempParameterDescription.getDescription() != null) {
								tempDescription += ": " + tempParameterDescription.getDescription();
							}
							acceptor.accept(createCompletionProposal(tempName, tempDescription, null, context));
						}
					}
				}
			} catch (ClassNotFoundException exc) {
				exc.printStackTrace();
			} catch (InstantiationException exc) {
				exc.printStackTrace();
			} catch (IllegalAccessException exc) {
				exc.printStackTrace();
			} catch (JavaModelException exc) {
				exc.printStackTrace();
			}

		}
	}

	private static final Pattern CLASS_NAME_PATTERN = Pattern.compile("(.*)\\.([^\\.]*)");

	protected EclipseResourceProvider generateResourceProvider() {
		return new EclipseResourceProvider() {

			private IType searchResult;

			@Override
			public IType findCompilationUnitForClassName(String aFullyQualifiedClassName) {
				Matcher tempMatcher = CLASS_NAME_PATTERN.matcher(aFullyQualifiedClassName);
				if (tempMatcher.matches()) {
					final String tempPackageName = tempMatcher.group(1);
					final String tempClassName = tempMatcher.group(2);

					SearchPattern pattern = SearchPattern.createPattern(tempClassName, IJavaSearchConstants.TYPE,
							IJavaSearchConstants.DECLARATIONS, SearchPattern.R_EXACT_MATCH
									| SearchPattern.R_CASE_SENSITIVE);
					IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
					SearchRequestor requestor = new SearchRequestor() {

						@Override
						public void acceptSearchMatch(SearchMatch aMatch) throws CoreException {
							IType tempType = (IType) aMatch.getElement();
							if (searchResult == null && !tempType.isBinary()
									&& tempPackageName.equals(tempType.getPackageFragment().getElementName())) {
								searchResult = tempType;
							}
						}

						@Override
						public void endReporting() {
							synchronized (this) {
								notifyAll();
							}
						}
					};

					SearchEngine searchEngine = new SearchEngine();

					try {
						searchEngine.search(pattern,
								new SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope,
								requestor, null);
					} catch (CoreException exc) {
						exc.printStackTrace();
					}

					synchronized (requestor) {
						if (searchResult != null) {
							return searchResult;
						} else {
							try {
								requestor.wait();
							} catch (InterruptedException exc) {
								// ignore
							}
							return searchResult;
						}
					}
				}

				return null;
			}
		};
	}

	private static final class BlockingProgressMonitor extends NullProgressMonitor {

		private boolean hasFinished;

		@Override
		public void done() {
			synchronized (this) {
				hasFinished = true;
				notifyAll();
			}
		}

		public void waitForCompletion() throws InterruptedException {
			synchronized (this) {
				if (hasFinished) {
					return;
				} else {
					wait();
				}
			}
		}
	}
}
